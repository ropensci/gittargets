% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tar_git_checkout.R
\name{tar_git_checkout}
\alias{tar_git_checkout}
\title{Check out a snapshot of the data (Git)}
\usage{
tar_git_checkout(
  ref = "HEAD",
  code = getwd(),
  store = targets::tar_config_get("store"),
  force = FALSE
)
}
\arguments{
\item{ref}{Character of length 1, reference
(branch name, Git SHA1 hash, etc.) of the code commit
associated with the data snapshot to check out.
In most cases, it is best to switch branches in the code
instead of manually setting \code{ref}. But if you do need to set \code{ref},
the \code{commit_code} column of the data frame produced by \code{\link[=tar_git_log]{tar_git_log()}}
shows possible options.}

\item{code}{Character of length 1, directory path to the code repository,
usually the root of the \code{targets} project.}

\item{store}{Character of length 1, path to the data store of the pipeline.
If \code{NULL}, the \code{store} setting is left unchanged in the
YAML configuration file (default: \verb{_targets.yaml}).
Usually, the data store lives at \verb{_targets}.
Set \code{store} to a custom directory
to specify a path other than \verb{_targets/}. The path need not exist
before the pipeline begins, and it need not end with "_targets",
but it must be writeable.
For optimal performance, choose a storage location
with fast read/write access.
If the argument \code{NULL}, the setting is not modified.
Use \code{\link[targets:tar_config_unset]{tar_config_unset()}} to delete a setting.}

\item{force}{ignore conflicts and overwrite modified files}
}
\value{
Nothing (invisibly).
}
\description{
Check out a snapshot of the data associated with
a particular code commit (default: \code{HEAD}).
}
\examples{
if (Sys.getenv("GITTARGETS_EXAMPLES") == "true") {
targets::tar_dir({ # Containing code does not modify the user's filespace.
# Work on an initial branch.
targets::tar_script(tar_target(data, "old_data"))
targets::tar_make()
targets::tar_read(data) # "old_data"
gert::git_init()
gert::git_add("_targets.R")
gert::git_commit("First commit")
gert::git_branch_create("old_branch")
tar_git_init()
# Work on a new branch.
tar_git_snapshot(status = FALSE, verbose = FALSE)
targets::tar_script(tar_target(data, "new_data"))
targets::tar_make()
targets::tar_read(data) # "new_data"
gert::git_branch_create("new_branch")
gert::git_add("_targets.R")
gert::git_commit("Second commit")
tar_git_snapshot(status = FALSE, verbose = FALSE)
# Go back to the old branch.
gert::git_branch_checkout("old_branch")
# The target is out of date because we only reverted the code.
targets::tar_outdated()
# But tar_git_checkout() lets us restore the old version of the data!
tar_git_checkout()
targets::tar_read(data) # "old_data"
# Now, the target is up to date! And we did not even have to rerun it!
targets::tar_outdated()
})
}
}
\seealso{
Other git: 
\code{\link{tar_git_init}()},
\code{\link{tar_git_log}()},
\code{\link{tar_git_snapshot}()},
\code{\link{tar_git_status_code}()},
\code{\link{tar_git_status_data}()},
\code{\link{tar_git_status_targets}()},
\code{\link{tar_git_status}()}
}
\concept{git}
